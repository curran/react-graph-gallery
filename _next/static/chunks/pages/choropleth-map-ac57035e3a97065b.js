(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7476],{7695:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/choropleth-map",function(){return n(3445)}])},3445:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return w}});var o=n(5893);n(7294);var i=n(153),a=n(9965),r=n(7262),s=n(3572),h=n(1122),d=n(6820),c=n(505),l=n(1664),p=n.n(l),u=n(5796),j=n(6438),m=n(7109),x=n(8893),g=n(3167);let f=(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)("p",{children:["A"," ",(0,o.jsx)("a",{href:"https://www.data-to-viz.com/graph/choropleth.html",children:"choropleth map"})," ","displays divided geographical areas or regions that are coloured in relation to a numeric variable. It enables the study of how a variable evolves across a geographical area."]}),(0,o.jsxs)("p",{children:["Once you understood how to draw a ",(0,o.jsx)(p(),{href:"/map",children:"map background"})," ","from a geoJson file, it is just a matter of ",(0,o.jsx)("b",{children:"coloring"})," each region with the appropriate color. On top of this, it is advised to add a"," ",(0,o.jsx)("b",{children:"color legend"})," and some interactivity (",(0,o.jsx)("b",{children:"hover effect"})," and"," ",(0,o.jsx)("b",{children:"tooltip"}),")."]}),(0,o.jsxs)("p",{children:["This webpage is a tutorial coming with explanation and code sandboxes. It explains how to build interactive choropleth map with ",(0,o.jsx)("b",{children:"React"})," and"," ",(0,o.jsx)("b",{children:"D3.js"}),"."]})]});function w(){return(0,o.jsxs)(i.A,{title:"Building Choropleth Maps with React and D3.js: A Step-by-Step Tutorial",seoDescription:"Learn how to create interactive choropleth maps using React and D3.js in this comprehensive tutorial. Follow along as we provide clear explanations and code sandboxes to guide you through each concept, empowering you to build visually appealing and data-driven maps.",children:[(0,o.jsx)(a.Z,{title:"Choropleth Map",description:f,chartType:"choropleth"}),(0,o.jsx)("h2",{id:"data",children:"The Data"}),(0,o.jsx)("p",{children:"Two pieces of information are required to build a choropleth map:"}),(0,o.jsx)("h3",{children:"→ Geographic information"}),(0,o.jsxs)("p",{children:["The first thing you need to build a map is the 2d coordinates of the"," ",(0,o.jsx)("b",{children:"boundaries"})," of the regions you want to represent. If you are trying to build a world map, you need to know where the country boundaries are located \uD83E\uDD37‍♀️."]}),(0,o.jsxs)("p",{children:["Several formats exist to store such a piece of information. When working with d3.js, the expected format is"," ",(0,o.jsx)("a",{href:"https://en.wikipedia.org/wiki/GeoJSON",target:"_blank",children:"geoJSON"}),". A geoJSON file looks pretty much like this:"]}),(0,o.jsx)("br",{}),(0,o.jsx)(s.d,{code:b}),(0,o.jsxs)("p",{children:["It is basically an object, with a ",(0,o.jsx)("code",{children:"features"})," property that is of great interest. This prop is an ",(0,o.jsx)("code",{children:"array"}),", each item of the array being a shape that we will be able to draw."]}),(0,o.jsxs)("p",{children:["This format is extensively described in the"," ",(0,o.jsx)(p(),{href:"/map",children:"background map"})," section of the gallery. It explains how it is structured, where to find it, how to work with it and how to draw its content. Check it out!"]}),(0,o.jsx)(j.J,{href:"/map",isFilled:!0,size:"sm",children:"Map section"}),(0,o.jsx)("h3",{children:"→ Numeric information"}),(0,o.jsx)("p",{children:"We need another piece of information that provides a numeric value for each region of the geoJson file. This information will be translated into a color on the choropleth map."}),(0,o.jsx)(s.d,{code:y}),(0,o.jsx)("h2",{id:"d3-geo",children:"D3-geo"}),(0,o.jsxs)("p",{children:["A geoJson file provides coordinates on a ",(0,o.jsx)("b",{children:"sphere"}),". But we want to display information on a ",(0,o.jsx)("b",{children:"screen"})," which is a 2d space."]}),(0,o.jsxs)("p",{children:["As a result we need to use a"," ",(0,o.jsx)("a",{href:"https://en.wikipedia.org/wiki/Map_projection",children:"projection"})," to transform the initial coordinates in a SVG or canvas path."]}),(0,o.jsxs)("p",{children:["This is a ",(0,o.jsx)("b",{children:"very tricky job"}),". Fortunately, d3 has everything we need in its ",(0,o.jsx)("b",{children:"d3-geo"})," module \uD83D\uDC99. You can install this module in your react project as follow:"]}),(0,o.jsx)(s.d,{code:v}),(0,o.jsxs)("p",{children:["All the map examples of this gallery rely on this ",(0,o.jsx)("code",{children:"d3-geo"})," ","module. I strongly encourage you to take a look at the"," ",(0,o.jsx)("a",{href:"https://github.com/d3/d3-geo",children:"official documentation"}),". The examples provided here are based on it, trying to make it easier to understand."]}),(0,o.jsx)(j.J,{isFilled:!0,size:"sm",href:"https://github.com/d3/d3-geo",children:"d3-geo doc"}),(0,o.jsx)("h3",{children:"→ Note on Typescript"}),(0,o.jsx)("p",{children:"If you are working in a typescript environment (you should!), you probably wonder how to type the geoJson dataset properly."}),(0,o.jsxs)("p",{children:["Fortunately, the"," ",(0,o.jsx)("a",{href:"https://github.com/DefinitelyTyped/DefinitelyTyped",children:"DefinitelyTyped"})," ","repo has everything we need as always. You can load all the types we need using:"]}),(0,o.jsx)(s.d,{code:D}),(0,o.jsxs)("p",{children:["Once this is done, you can type the geoJson data as a"," ",(0,o.jsx)("code",{children:"FeatureCollection"}),":"]}),(0,o.jsx)(s.d,{code:M}),(0,o.jsx)("h2",{id:"skeleton",children:"Component skeleton"}),(0,o.jsxs)("p",{children:["The goal here is to create a ",(0,o.jsx)("code",{children:"Map"})," component that will be stored in a ",(0,o.jsx)("code",{children:"Map.tsx"})," file. This component requires 3 props to render: a ",(0,o.jsx)("code",{children:"width"}),", a ",(0,o.jsx)("code",{children:"height"}),", and some"," ",(0,o.jsx)("code",{children:"geoJson"})," data."]}),(0,o.jsxs)("p",{children:["The shape of the ",(0,o.jsx)("code",{children:"data"})," is described above. The"," ",(0,o.jsx)("code",{children:"width"})," and ",(0,o.jsx)("code",{children:"height"})," will be used to render an"," ",(0,o.jsx)("code",{children:"svg"})," element in the DOM, in which we will insert the map."]}),(0,o.jsxs)("p",{children:["To put it in a nutshell, that's the skeleton of our ",(0,o.jsx)("code",{children:"Map"})," ","component:"]}),(0,o.jsx)(s.d,{code:k}),(0,o.jsxs)("p",{children:["It's fundamental to understand that with this code organization, d3.js will be used to prepare the SVG ",(0,o.jsx)("code",{children:"path"}),", but it's React that will render them in the ",(0,o.jsx)("code",{children:"return()"})," statement. We won't use d3 methods like ",(0,o.jsx)("code",{children:"append"})," that you can find in usual"," ",(0,o.jsx)("a",{href:"https://www.d3-graph-gallery.com",children:"d3.js examples"}),"."]}),(0,o.jsx)("h2",{id:"first map",children:"First Map"}),(0,o.jsxs)("p",{children:["Most of the magick comes from the ",(0,o.jsx)("code",{children:"geoPath()"})," function of d3."]}),(0,o.jsxs)("p",{children:["We want to draw a shape in SVG for every item of the geoJson input file. In the DOM this is done using a ",(0,o.jsx)("code",{children:"path"})," element that has a"," ",(0,o.jsx)("code",{children:"d"})," attribute."]}),(0,o.jsxs)("p",{children:["The ",(0,o.jsx)("code",{children:"geoPath()"})," function helps us doing this."," ",(0,o.jsx)("code",{children:"geoPath()"})," is a function that returns a function. It can be invoked this way:"]}),(0,o.jsx)(s.d,{code:T}),(0,o.jsx)("p",{children:"Pretty short. We just invoke the function, providing it with the projection of our choice (more on this later)."}),(0,o.jsxs)("p",{children:[(0,o.jsx)("code",{children:"geoPathGenerator"})," is now a function that expects an item of the geoJSON dataset as input and returns a SVG ",(0,o.jsx)("code",{children:"path"})," from it. It is thus possible to loop through the geoJson file and create a",(0,o.jsx)("code",{children:"path"})," element with the right ",(0,o.jsx)("code",{children:"d"})," attribute for each shape:"]})," ",(0,o.jsx)(s.d,{code:P}),(0,o.jsx)("p",{children:"This leads us to our first simple world map. Shapes are computed with d3. Rendering is made with react. \uD83C\uDF89"}),(0,o.jsx)(h.$,{VizComponent:u._,vizName:"BackgroundMapBasic",maxWidth:900,height:500,caption:"First very basic map made with d3.js and React."}),(0,o.jsx)("p",{children:"Note: I removed Antartica and chose the most famous yet highly criticiced: Mercator."}),(0,o.jsx)("h2",{id:"projections",children:"Projections"}),(0,o.jsxs)("p",{children:["Projections transform ",(0,o.jsx)("b",{children:"spherical polygonal"})," geometry to"," ",(0,o.jsx)("b",{children:"planar polygonal"})," geometry. D3 provides implementations of several classes of standard projections."]}),(0,o.jsx)(j.J,{isFilled:!0,size:"sm",href:"https://github.com/d3/d3-geo#projections",children:"all supported projections"}),(0,o.jsx)("p",{children:(0,o.jsx)("br",{})}),(0,o.jsx)("p",{children:"Setting up a projection always follow the same pattern:"}),(0,o.jsx)(s.d,{code:I}),(0,o.jsxs)("p",{children:[(0,o.jsx)("code",{children:"scale"})," and ",(0,o.jsx)("code",{children:"center"})," are in my opinion the 2 most useful options that you will have to setup for your projections. But once more, take a look at the doc to see every possibilities."]}),(0,o.jsx)("p",{children:"Now, here is a little playground to check some of the various offered projections."}),(0,o.jsx)(h.$,{VizComponent:m.W,vizName:"BackgroundMapProjection",maxWidth:900,height:600,caption:"An interactive playground to check how a few map projections look like on a world map."}),(0,o.jsx)(x.H,{text:"Make a smooth transition between projections"}),(0,o.jsx)("h2",{id:"canvas",children:"Better performance with Canvas"}),(0,o.jsxs)("p",{children:[(0,o.jsx)("code",{children:"canvas"})," is recommended for dynamic or interactive data visualizations to improve ",(0,o.jsx)("b",{children:"performance"}),". Indeed, drawing in SVG requires to add many elements to the DOM, which can slow down your application, especially if you try to ",(0,o.jsx)("b",{children:"animate transition"})," between states."]}),(0,o.jsx)("p",{children:"Canvas rendering is typically faster than SVG, but requires more effort to implement styling and interaction."}),(0,o.jsxs)("p",{children:["Fortunatelly, the ",(0,o.jsx)("code",{children:"geoPath()"})," function has everything we need to easily draw our shapes in canvas. If a ",(0,o.jsx)("code",{children:"context"})," is passed to it, it understands that we are dealing with canvas and does not output SVG path like above."]}),(0,o.jsx)("p",{children:"Check the example below to see how to draw with canvas:"}),(0,o.jsx)(h.$,{VizComponent:g.U,vizName:"BackgroundMapCanvas",maxWidth:900,height:600,caption:"A simple map based on a geoJson file, render using react in a canvas element."}),(0,o.jsxs)("p",{children:[(0,o.jsx)("b",{children:"Performance"})," in dataviz using React is a ",(0,o.jsx)("b",{children:"big"})," topic. It's impossible to go in depth here! I will publish a dedicated blog post on the topic soon, with a special focus on canvas. Please"," ",(0,o.jsx)(p(),{href:"subscribe",children:"subscribe"})," to the newsletter if you want to be notified."]}),(0,o.jsx)(j.J,{isFilled:!0,size:"sm",href:"/subscribe",children:"Subscribe"}),(0,o.jsxs)("p",{children:[(0,o.jsx)("br",{})," ",(0,o.jsx)("br",{})]}),(0,o.jsx)(c.r,{chartId:"map"}),(0,o.jsx)(d.Z,{chartId:"map"}),(0,o.jsx)("div",{className:"full-bleed border-t h-0 bg-gray-100 mb-3 mt-24"}),(0,o.jsx)(r.Z,{chartFamily:"map"}),(0,o.jsx)("div",{className:"mt-20"})]})}let b='\n{\n  "type": "FeatureCollection",\n  "features": [\n    {\n      "type": "Feature",\n      "geometry": {\n        "type": "Point",\n        "coordinates": [102.0, 0.5]\n      },\n      "properties": {\n        "prop0": "value0"\n      }\n    },\n    {\n      "type": "Feature",\n      "geometry": {\n        "type": "LineString",\n        "coordinates": [\n          [102.0, 0.0],\n          [103.0, 1.0],\n          [104.0, 0.0],\n          [105.0, 1.0]\n        ]\n      },\n      "properties": {\n        "prop0": "value0",\n        "prop1": 0.0\n      }\n    },\n    ...\n  ]\n}'.trim(),y='\n[\n  {\n    "name": "Antigua and Barbuda",\n    "code": "ATG",\n    "pop": 83039\n  },\n  {\n    "name": "Algeria",\n    "code": "DZA",\n    "pop": 32854159\n  },\n  ...\n]\n}'.trim(),v="\nnpm install d3-geo\n".trim(),k='\nimport * as d3 from "d3"; // we will need d3.js\n\ntype MapProps = {\n  width: number;\n  height: number;\n  data: GeoJsonData;\n};\n\nexport const Map = ({ width, height, data }: MapProps) => {\n\n  // read the data\n  // create a geoPath generator with the proper projection\n  // build the paths\n\n  return (\n    <div>\n      <svg width={width} height={height}>\n        // render all the <path>s\n      </svg>\n    </div>\n  );\n};\n'.trim(),T="\nconst geoPathGenerator = d3.geoPath().projection(projection);\n".trim(),P='\nconst allSvgPaths = data.features\n  .map((shape) => {\n    return (\n      <path\n        key={shape.id}\n        d={geoPathGenerator(shape)}\n        stroke="black"\n        fill="#cb1dd1"\n      />\n    );\n});\n'.trim(),D="\nnpm install --save @types/geojson\n".trim(),M="\ntype MapProps = {\n  width: number;\n  height: number;\n  data: FeatureCollection;\n};".trim(),I="\nconst projection = d3\n  .geoMercator()                              // name of the projection\n  .scale(width / 2 / Math.PI)                 // scale: bigger value = more zoom\n  .center([2.34, 48.86])                      // coordinate of the center of the map. e.g. 2 and 48 for Paris\n  ...other options if needed\n".trim()}},function(e){e.O(0,[3996,3526,5660,645,1188,1573,9774,2888,179],function(){return e(e.s=7695)}),_N_E=e.O()}]);